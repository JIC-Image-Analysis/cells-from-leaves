function [] = sampleArrows8(orientation)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This script displays BASL polarity arrows on a leaf. It can display the
% raw arrow data, or downsample it. Arrows are typically coloured according
% to their orientation, and this orientation information can be written out
% to a csv file. Four figures are generated: one with both processed and raw data,
% one with only processed data plotted on the leaf, one on black, and one on white.
%
% There are typically two methods of operation. Firstly, the raw arrow
% information can be displayed (no downsampling). Or the arrow data is
% downsampled in some way.
%
% Parameters must be edited in this m file, in the code that follows
% all this green stuff.
%
% If you just run 'sampleArrows5' from Matlab, the script will ask you to
% draw a proximodistal line on the leaf. If you look in the config file
% generated by this script when you process a leaf, the field PD Axis Orientation
% tells you the orientation of the line drawn (e.g. 61). You can then run 'sampleArrows5(61)'
% to generate the same result without having to redraw the PD axis.
%
% Requests either a directory of ImageJ ROIs or a CSV (as generated by
% Tjelvar's software), and an image of the leaf. Outputs a csv with a
% specified file name, containing the orientation of each downsampled
% arrow, and a corresponding text file detailing the input parameters.
%
% Technical note on the way this script works: This script creates a number
% of reference points on the leaf and averages the orientation of the raw
% data within a given radius. The reference points can be either the raw
% data or a grid placed over the leaf. It follows that when using the
% raw data as a reference, setting the radius (maxDist) to 0, just returns
% the raw data, which aligns exactly with the reference grid. It also follows
% that doing the same with the rectanguar grid returns nonsense.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%% Parameter explanation %%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% The following are downsampling parameters
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% useRandom
% For debugging and sanity checking. Instead of reading arrows in from a CSV or ROIs, it generates 1000
% randomly positioned and oriented arrows. May not work anymore.
%%%%%%%%%%%%%%%%
% useGrid
% If true, samples arrows based on an alternating grid pattern placed over
% the image.
% If false, chooses a number of arrows (determined by nRandom) and 
%%%%%%%%%%%%%%%%
% nRandom
% Only used if useGrid is false.
% In which case we want to downsample by randomly selecting a number of
% arrows, determined by this parameter.
% If set to -1, all arrows are used.
%%%%%%%%%%%%%%%%
% maxdist
% The radius of the circle around an arrow to use for sampling.
% If useGrid is false, and maxdist is 0, the raw arrow data is plotted.
% Any value of maxdist greater than 0 results in sampling.
%%%%%%%%%%%%%%%%
% neighbourThreshold
% This is the minimum number of arrows needed for downsampling to be allowed in a circle. 
%%%%%%%%%%%%%%%%
% useROIFiles
% If true, the script will ask for a folder containing ImageJ ROI files.
%%%%%%%%%%%%%%%%
% ignorePolarity
% The default is for ignorePolarity to be false. This means that arrows are
% plotted. If ignorePolarity is true, lines will be plotted instead, as
% required if displaying cell orientations (tensors) instead of BASL
% (vectors). Uses PCA to calculate the mean orientation.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% The following are display parameters
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% useVariance
% If true, and assuming downsampling is used, arrows are coloured according
% the variance of the sample. If the sample contains few, or even 1 arrow,
% obviously the variance is meaningless.
%%%%%%%%%%%%%%%%
% varianceRange
% The colormap for variance is linearly distributed between the the lower and
% upper thresholds set by the varianceRange parameter. Variance above or
% below the threshold are capped at the extremes (white or red).
%%%%%%%%%%%%%%%%
% colourmap360
% If true, arrows are coloured using a colormap where left and right
% pointing arrows have different colours (i.e. all orientatoins have a
% unique colour). If false, the colormap is symmetrical around the leaf
% proximodistal axis.
%%%%%%%%%%%%%%%%
% arrowLength
% The length of the arrows plotted. Note that arrow appearance varies
% between Mac and Windows machines.
%%%%%%%%%%%%%%%%
% drawCircles
% If true, circles (showing the downsample regions) are displayed on one of the output figures
%%%%%%%%%%%%%%%%
% colourByNeighbours
% If true, the arrows in each downsampled region are given a unique colour.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


useGrid = true;
useROIFiles = false;
swapROICoords = false; % True for Martin's ROIs
nRandom = -1;%500;
maxdist = 105; %105; %0; %35;%125;%105;
neighbourThreshold = 3; %0; %5
ignorePolarity = true;
useRandom = false;

useVariance = false;
varianceRange = [0.0 0.4];
colourmap360 = false;
colourmap90 = true;
arrowLength = 80;%100;%50; %100; %50; %100;
drawCircles = false;
colourByNeighbours = false;

arrowObjs = [];
figH = figure;
set(gcf,'Renderer','painters');

[imFileName,imPathName,~] = uigetfile({'*.png';'*.tif'},'Choose an image of a leaf');
img = imread(sprintf('%s%c%s',imPathName,filesep,imFileName));
originalImg = img;

if nargin == 0
    imshow(img);
    % Get the user to draw a proximodistal line on the leaf
    lineH = imline;
    linePos = lineH.getPosition;
    lineVec = linePos(2,:) - linePos(1,:);
    orientation = cart2pol(lineVec(1)./norm(lineVec),lineVec(2)./norm(lineVec)) + pi/2;
else
    orientation = deg2rad(orientation);
end

imgRot = imrotate(img,round(rad2deg(orientation)));
img = imgRot;

imH = imshow(img);
set(imH,'tag','leafimg');
axPos = get(gca,'Position'); %# gca gets the handle to the current axes
set(gca,'Ydir','reverse');
hold on;
hs = [];
offsetFromMean = [];

% Load the raw arrow data and rotate the leaf/arrows according to the user
% specified proximodistal axis.
if useRandom
%     % generate random arrows
    roiFiles = zeros(1000,1);
    centroid = zeros(1000,2);
    randx = (size(img,2)/4) + (rand(1000,1)*size(img,2))/2;
    randy = (size(img,1)/4) + (rand(1000,1)*size(img,1))/2;
    randx2 = randx + 50*(1-rand(1000,1)*2);
    randy2 = randy + 50*(1-rand(1000,1)*2);
    for i = 1:1000        
        arrowObjs(i).arrow.vnLinePoints(3) = randx2(i);
        arrowObjs(i).arrow.vnLinePoints(4) = randy2(i);
        arrowObjs(i).arrow.vnLinePoints(1) = randx(i);
        arrowObjs(i).arrow.vnLinePoints(2) = randy(i);
        
        hs = [hs line([arrowObjs(i).arrow.vnLinePoints(1) arrowObjs(i).arrow.vnLinePoints(3)],[arrowObjs(i).arrow.vnLinePoints(2) arrowObjs(i).arrow.vnLinePoints(4)],'LineWidth',3,'color','magenta')];
        hs = [hs scatter(arrowObjs(i).arrow.vnLinePoints(2), arrowObjs(i).arrow.vnLinePoints(1),'go','filled')];

        arrowObjs(i).arrow.centrePos = [mean(arrowObjs(i).arrow.vnLinePoints(1) + arrowObjs(i).arrow.vnLinePoints(3)) mean(arrowObjs(i).arrow.vnLinePoints(2) + arrowObjs(i).arrow.vnLinePoints(4))];
        centroid(i,:) = [arrowObjs(i).arrow.vnLinePoints(3) arrowObjs(i).arrow.vnLinePoints(4)];
    end
else
    if ~useROIFiles
        % Load data file from automated tool
        [FileName,PathName,~] = uigetfile('*.csv','Choose a tensor CSV file');
        arrows = csvread(sprintf('%s%c%s',PathName,filesep,FileName),1,0);
        tmp = arrows(:,4:5);
        arrows(:,4:5) = arrows(:,2:3);
        arrows(:,2:3) = tmp;
        
        R = [cos(orientation) -sin(orientation); sin(orientation) cos(orientation)];
        centroid = [size(originalImg,2)/2 size(originalImg,1)/2];
        centroidTemp = repmat(centroid,size(arrows,1),1);
        
        centroidRot = [size(imgRot,2)/2 size(imgRot,1)/2];
        centroidRotTemp = repmat(centroidRot,size(arrows,1),1);
        
        arrows(:,4:5) = centroidRotTemp + (arrows(:,4:5) - centroidTemp)*R;
        arrows(:,2:3) = centroidRotTemp + (arrows(:,2:3) - centroidTemp)*R;

        roiFiles = zeros(length(arrows),1);
        centroid = zeros(length(roiFiles),2);
        for i = 1:size(arrows,1)
            arrowObjs(i).arrow.vnLinePoints(3) = arrows(i,3);
            arrowObjs(i).arrow.vnLinePoints(4) = arrows(i,2);
            arrowObjs(i).arrow.vnLinePoints(1) = arrows(i,5);
            arrowObjs(i).arrow.vnLinePoints(2) = arrows(i,4);
            
            hs = [hs line([arrowObjs(i).arrow.vnLinePoints(2) arrowObjs(i).arrow.vnLinePoints(4)],[arrowObjs(i).arrow.vnLinePoints(1) arrowObjs(i).arrow.vnLinePoints(3)],'LineWidth',3,'color','magenta')];
            hs = [hs scatter(arrowObjs(i).arrow.vnLinePoints(2), arrowObjs(i).arrow.vnLinePoints(1),'go','filled')];
            centroid(i,:) = [arrowObjs(i).arrow.vnLinePoints(4) arrowObjs(i).arrow.vnLinePoints(3)];
        end
    else
        % Load Cathy's hand labelled data from imageJ
            dirOfROIs = uigetdir();
            roiFiles = dir(sprintf('%s/*.roi',dirOfROIs));
        %     dirOfROIs = '.';
        %     roiFiles = dir('0*.roi');
        %     roiFiles = [roiFiles ;dir('1*.roi')];
        if swapROICoords
            orderOfPts = [3 4 1 2];
        else
            orderOfPts = [1 2 3 4];
        end
        arrows = zeros(length(roiFiles),5);
        for i = 1:length(roiFiles)
            arrowObj = ReadImageJROI(sprintf('%s/%s',dirOfROIs,roiFiles(i).name),'Choose a directory of imageJ ROIs');
            if strcmp(arrowObj.strType,'Rectangle')
                warning(sprintf('ROI file %s ignored as it''s of type %s ', roiFiles(i).name,arrowObj.strType))
                continue;
            end
            arrows(i,4) = arrowObj.vnLinePoints(orderOfPts(1));
            arrows(i,5) = arrowObj.vnLinePoints(orderOfPts(2));
            arrows(i,2) = arrowObj.vnLinePoints(orderOfPts(3));
            arrows(i,3) = arrowObj.vnLinePoints(orderOfPts(4));
        end
        
        R = [cos(orientation) -sin(orientation); sin(orientation) cos(orientation)];
        centroid = [size(originalImg,2)/2 size(originalImg,1)/2];
        centroidTemp = repmat(centroid,size(arrows,1),1);
        
        centroidRot = [size(imgRot,2)/2 size(imgRot,1)/2];
        centroidRotTemp = repmat(centroidRot,size(arrows,1),1);
        
        arrows(:,4:5) = centroidRotTemp + (arrows(:,4:5) - centroidTemp)*R;
        arrows(:,2:3) = centroidRotTemp + (arrows(:,2:3) - centroidTemp)*R;

        roiFiles = zeros(length(arrows),1);
        centroid = zeros(length(roiFiles),2);
        for i = 1:size(arrows,1)
            arrowObjs(i).arrow.vnLinePoints(3) = arrows(i,3);
            arrowObjs(i).arrow.vnLinePoints(4) = arrows(i,2);
            arrowObjs(i).arrow.vnLinePoints(1) = arrows(i,5);
            arrowObjs(i).arrow.vnLinePoints(2) = arrows(i,4);
            
            hs = [hs line([arrowObjs(i).arrow.vnLinePoints(2) arrowObjs(i).arrow.vnLinePoints(4)],[arrowObjs(i).arrow.vnLinePoints(1) arrowObjs(i).arrow.vnLinePoints(3)],'LineWidth',3,'color','magenta')];
            hs = [hs scatter(arrowObjs(i).arrow.vnLinePoints(2), arrowObjs(i).arrow.vnLinePoints(1),'go','filled')];

            centroid(i,:) = [arrowObjs(i).arrow.vnLinePoints(4) arrowObjs(i).arrow.vnLinePoints(3)];
        end
    end
end

if useGrid
    % Place a grid over the leaf to use when sampling
        dim1Step = maxdist*2;
        dim2Step = (sqrt(3) * maxdist*2) / 2;
        
        gridXs = dim1Step:dim1Step:size(img,1)-dim1Step;
        gridYs = dim2Step:dim2Step:size(img,2)-dim2Step;
        grid = zeros(length(gridXs)*length(gridYs),2);
        count = 0;
        for i = 1:length(gridXs)
            for n = 1:length(gridYs)
                if mod(n,2) == 0
                    offset = dim1Step/2;
                else
                    offset = 0;
                end
                count = count + 1;
                grid(count,:) = [gridYs(n) gridXs(i)+offset];
            end
        end
        centroid(end+1:end+length(grid),:) = grid;
        roisToPlot = length(roiFiles)+1 : length(centroid);
else
    % Choose a subset of arrows to use instead of a grid
    % Of course, you CAN just use all the arrows
    randOrder = randperm(length(roiFiles));
    if nRandom ~= -1
        roisToPlot = randOrder(1:nRandom);
    else
        roisToPlot = 1:length(roiFiles);
    end
end

% Downsample (get neighbours, calc mean and var)
distances = squareform(pdist(centroid));
colors = jet(20);

variancemap = [ones(1,34);1:-0.03:0;1:-0.03:0]';
Vs(length(roisToPlot)) = 0;
avgDir(length(roisToPlot),2) = 0;
avgDir(:) = inf;
avgDirDegrees(length(roisToPlot)) = 0;
avgDirDegrees(:) = inf;
neighboursPerRegion = [];
for i = 1:length(roisToPlot)
    sprintf('%d of %d\n',i,length(roisToPlot))
    idxsOfneighboursToUse = distances(roisToPlot(i),:) <= maxdist;
    idxsOfneighboursToUse = idxsOfneighboursToUse(1:length(roiFiles));
    neighboursToUse = arrowObjs(idxsOfneighboursToUse);

    % Plot the neighbours and colour according to their grouping
    if ~colourByNeighbours
        lineColour = [0.8 0.8 0.8];
    else
        coloridx = 1 + floor(rand*20);
        lineColour = colors(coloridx,:);
    end
    for n = 1:length(neighboursToUse)
        hs = [hs line([neighboursToUse(n).arrow.vnLinePoints(2) neighboursToUse(n).arrow.vnLinePoints(4)],[neighboursToUse(n).arrow.vnLinePoints(1) neighboursToUse(n).arrow.vnLinePoints(3)],'Color',lineColour,'LineWidth',3)];
    end
    
    unitvec = [0 0];
    % Calculate mean orientation
    if ~ignorePolarity
        for n = 1:length(neighboursToUse)
            unitvec = unitvec + ([neighboursToUse(n).arrow.vnLinePoints(4) - neighboursToUse(n).arrow.vnLinePoints(2) neighboursToUse(n).arrow.vnLinePoints(3) - neighboursToUse(n).arrow.vnLinePoints(1)])./norm([neighboursToUse(n).arrow.vnLinePoints(4) - neighboursToUse(n).arrow.vnLinePoints(2) neighboursToUse(n).arrow.vnLinePoints(3) - neighboursToUse(n).arrow.vnLinePoints(1)]);
        end
    else
        % Average cell orientations rather than BASL vectors
        neighbourPts = [];
        for n = 1:length(neighboursToUse)
            neighbourPts = [neighbourPts ; -([neighboursToUse(n).arrow.vnLinePoints(4) - neighboursToUse(n).arrow.vnLinePoints(2) neighboursToUse(n).arrow.vnLinePoints(3) - neighboursToUse(n).arrow.vnLinePoints(1)])./norm([neighboursToUse(n).arrow.vnLinePoints(4) - neighboursToUse(n).arrow.vnLinePoints(2) neighboursToUse(n).arrow.vnLinePoints(3) - neighboursToUse(n).arrow.vnLinePoints(1)]) ;([neighboursToUse(n).arrow.vnLinePoints(4) - neighboursToUse(n).arrow.vnLinePoints(2) neighboursToUse(n).arrow.vnLinePoints(3) - neighboursToUse(n).arrow.vnLinePoints(1)])./norm([neighboursToUse(n).arrow.vnLinePoints(4) - neighboursToUse(n).arrow.vnLinePoints(2) neighboursToUse(n).arrow.vnLinePoints(3) - neighboursToUse(n).arrow.vnLinePoints(1)])];
        end
        if ~isempty(neighboursToUse)
            if size(neighbourPts,1) > 1
                [coeff,] = pca(neighbourPts);
                unitvec = [-coeff(1,1) -coeff(2,1)];
            end
        end

    end
    % Calculate variance
    if ~ignorePolarity
        Vs(i) = 1 - sqrt(unitvec(1)^2 + unitvec(2)^2)./length(neighboursToUse);
    else
        Vs(i) = 1;
    end
    avgDir(i,:) = unitvec./norm(unitvec);
    
    
    
    % Offset from mean
    for n = 1:length(neighboursToUse)
       if length(neighboursToUse) < neighbourThreshold
        continue;
       end
       neighbourVec = ([neighboursToUse(n).arrow.vnLinePoints(4) - neighboursToUse(n).arrow.vnLinePoints(2) neighboursToUse(n).arrow.vnLinePoints(3) - neighboursToUse(n).arrow.vnLinePoints(1)])./norm([neighboursToUse(n).arrow.vnLinePoints(4) - neighboursToUse(n).arrow.vnLinePoints(2) neighboursToUse(n).arrow.vnLinePoints(3) - neighboursToUse(n).arrow.vnLinePoints(1)]);
       neighbourVec = (neighbourVec./norm(neighbourVec));
       polval = cart2pol(neighbourVec(1),neighbourVec(2));
       polvalmean = cart2pol(avgDir(i,1),avgDir(i,2));
       difFromMean = rad2deg(polvalmean) - rad2deg(polval);
       if difFromMean < -180
        difFromMean = difFromMean + 360;
       end
       if difFromMean > 180
        difFromMean = 360 - difFromMean;
       end
       offsetFromMean = [offsetFromMean difFromMean];
    end
    
    polval = cart2pol(avgDir(i,1),avgDir(i,2));
    avgDirDegrees(i) = floor(rad2deg(polval));
    
    if drawCircles == true
        idxsOfneighboursToUse = distances(roisToPlot(i),:) <= maxdist;
        idxsOfneighboursToUse = idxsOfneighboursToUse(1:length(roiFiles));
        neighboursToUse = arrowObjs(idxsOfneighboursToUse);
        neighboursPerRegion = [neighboursPerRegion length(neighboursToUse)];
        if length(neighboursToUse) >= neighbourThreshold
            hs = [hs viscircles([centroid(roisToPlot(i),1) centroid(roisToPlot(i),2)], maxdist,'EdgeColor','black','LineWidth',2)];
        elseif ~isempty(neighboursToUse)
            hs = [hs viscircles([centroid(roisToPlot(i),1) centroid(roisToPlot(i),2)], maxdist,'EdgeColor','red','LineWidth',2)];
            avgDirDegrees(i) = inf;
        else
           % No neighbours. Don't plot anything. 
        end
    end
end

% minV = min(Vs);
% maxV = max(Vs);

minV = varianceRange(1);
maxV = varianceRange(2);

if colourmap360
    angleColours = jet(360);
elseif ~colourmap90
    angleColours = jet(180);
    angleColours(181:360,:) = flipdim(angleColours(1:180,:),1);
elseif colourmap90
    angleColours = flipdim(jet(180),1);
    angleColours = angleColours(1:90,:);
    angleColours(91:180,:) = flipdim(angleColours(1:90,:),1);
    angleColours(181:360,:) = flipdim(angleColours(1:180,:),1);
end

% Plot the averaged arrows
for i = 1:length(roisToPlot)
    sprintf('%d of %d\n',i,length(roisToPlot))
    if avgDirDegrees(i) == inf || isnan(avgDirDegrees(i))
        continue;
    end
    
    [figx] = dsxy2figxy([centroid(roisToPlot(i),1) size(img,1) - centroid(roisToPlot(i),2) axPos(3) axPos(4)]);
    [figy] = dsxy2figxy([centroid(roisToPlot(i),1) + avgDir(i,1)*arrowLength size(img,1) - (centroid(roisToPlot(i),2) + avgDir(i,2)*arrowLength) axPos(3) axPos(4)]);
    
    angleOffset = 270;
    angleOfArrow = avgDirDegrees(i) + angleOffset;
    if angleOfArrow > 359
        angleOfArrow = angleOfArrow - 360;
    end
    avgDirDegrees(i) = angleOfArrow;
    
    if useVariance
        V = Vs(i);
        varIdx = 1+floor(((V-minV)/(maxV-minV))*33);
        if varIdx > 34
            varIdx = 34;
    elseif varIdx == 0
            varIdx = 1;
        end
        plotColour =  variancemap(varIdx,:);
    else
        plotColour = angleColours(angleOfArrow + 1,:);
    end
    if ~ignorePolarity
        annotation('arrow',[figx(1) figy(1)],[figx(2) figy(2)],'color',plotColour,'LineWidth',2,'HeadWidth',8,'HeadLength',8);
    else
        annotation('line',[figx(1) figy(1)],[figx(2) figy(2)],'color',plotColour,'LineWidth',2);
    end
end

% Make fig with processed arrows
fig2 = figure;
imshow(img);
hold on;
fig3 = figure;
imshow(img);
hold on;
fig4 = figure;
imshow(img);
hold on;
copyobj(allchild(figH),fig2);
delete(hs);
copyobj(allchild(figH),fig3);
copyobj(allchild(figH),fig4);
imH = findobj(fig3,'tag','leafimg');
cdata = get(imH,'cdata');
cdata(:) = 255;
set(imH,'cdata',cdata);
imH = findobj(fig4,'tag','leafimg');
cdata = get(imH,'cdata');
cdata(:) = 0;
set(imH,'cdata',cdata);

% Remove inf and NaN from the list of orientations
% These occur when regions with too few neighbours are discarded
avgDirDegrees = avgDirDegrees(~isnan(avgDirDegrees)&~isinf(avgDirDegrees));

% Hist of BASL orientations
figure;
avgDirDegrees = avgDirDegrees - 180;
avgDirDegrees(avgDirDegrees>180) = avgDirDegrees(avgDirDegrees>180) - 360;
hist(avgDirDegrees,-180:1:180);
set(gca,'XLim',[-180 180]);
xlabel('Angle of BASL signal')
ylabel('Frequency')

% Hist of Variances
if useVariance
    figure;
    hist(Vs,20);
    xlabel('Variance')
    ylabel('Frequency')
end

% % % Hist of local variance (ie each vector from mean)
% figure;
% hist(offsetFromMean,180);
% xlabel('offset from mean')
% ylabel('Frequency')
% sprintf('Standard deviation of local regions: %0.2f',std(offsetFromMean))

% Display STD and write out csv containing angles
sprintf('Standard deviation: %0.2f',std(avgDirDegrees))
filename = input('Enter output filename');
csvwrite(filename,avgDirDegrees');

% Save input parameters to a similarly named file
fid = fopen(sprintf('%s_config.txt',filename),'w');
fprintf(fid, ['Image file = %s\nCSV file = %s\nuseRandom = %d\nuseGrid = %d\nnRandom = %d\nmaxdist = %d\nneighbourThreshold = %d\nuseROIFiles = %d\nignorePolarity = %d\n', ...
'useVariance = %d\ncolourmap360 = %d\narrowLength = %d\ndrawCircles = %d\ncolourByNeighbours = %d\n..............\nPD Axis Orientation = %d\nStandard Deviation = %0.2f\n'],...
sprintf('%s%s',imPathName,imFileName),sprintf('%s%s',PathName,FileName),useRandom,useGrid,nRandom,maxdist,neighbourThreshold,useROIFiles,ignorePolarity,useVariance,colourmap360,arrowLength,drawCircles,colourByNeighbours,round(rad2deg(orientation)),std(avgDirDegrees));
fclose(fid);
sprintf('Finished!')


